# Деривации

## Преговор

Научихме целия Nix език и се забавлявахме с функционално програмиране

## Какво е пакет?

- Пакет е просто редица инструкции как да компилираме и инсталираме програма
- Ако компилираме: къде да изтеглим сорс-кода, какви зависимости имаме, каква команда да пуснем за компилиране, къде да сложим резултата
- Ако взимаме готова бинарка: от къде да я вземем, как да пуснем patchElf, къде да сложим резултата
- Nix разбира се улеснява тези подробности като ги слага под един покрив: деривации

## Какво е деривация?

- attrset с предопределени атрибути
- който се подава на вградената `derivation` функция

```
derivation {
    # Задължителни
    system = "x86_64-linux";
    name = "hello";
    builder = ./build-script.sh;
    # Опционално
    args = [ "a" "b" ];
    outputs = [ "lib" ];
    /* Всички други атрибути се подават на builder
       като environment променливи */
}
```

## Функции над derivation

- Разбира се, да правиш скрипт от дъното за всяко нещо е трудоемко
- nixpkgs предлага няколко удобства; функции които използват `derivation`, но подават `system` автоматично и разбира се, предоставят `builder`
- една от тях вече сме виждали: `mkShell`

### mkShell с примерни стойности

```
pkgs.mkShell {
    name = "hello";
    packages = [ ... ];
    inputsFrom = [ ... ];
    shellHook = "echo hi";
}
```

---

- Нека да разгледаме сорс кода:

< https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/mkshell/default.nix >

- Виждаме, че има една по-значима функция около `derivation` - `mkDerivation`
- Тя се използва като основа на всички builder-и, дори нетривиалните!

## mkDerivation basics

Процесът по инсталиране се разделя на няколко фази (в този ред):

0. Unpack Phase: разархивиране на входните файлове, понеже много често се намират в архиви
1. Patch Phase: слагат се patch-ове; по-общо казано, правят се промени по изтеглените сорс-файлове
2. Configure Phase: конфигурира се средата за компилиране, примерно създаване на конфигурационни файлове които ще са полезни по време на компилация
3. Build Phase: пуска се нужната програма за компилиране
4. Check Phase: пускат се всички тестове, с целта да се провери дали компилацията е създала коректен резултат
5. Install Phase: резултатните данни се слагат във финалната им локация под `/nix/store`
6. Fixup Phase: финални (nix-specific) промени, примерно премахване на дебъг данни от резултата

---

- За всяка фаза имаме атрибтутът `namePhase` (name е едно от unpack, patch, configure, ...)
- Заедно с `preName` и `postName`, които съответно се изпълняват преди или след дадената фаза. Така можем конструктивно да променяме фази.
- Допълнително имаме и `dontName`, което е булева стойност, отразяваща дали дадената фаза да се изпълни.
  - Валидно е само за фазите, които се изпълняват по подразбиране
  - За другите (check phase), имаме `doName`
- Някои фази имат свои си атрибути, по-значими от които са:
  - Patch Phase: `patches`, списък от пачове които ще се сложат върху сорса
  - Configure Phase: `configureScript`, име на конфигурационен скрипт

---

- Извън фазите, другите важни атрибути са:
  - `name` за име на пакета
  - `version` за версия, използваме `name-version` за да обозначим пакета в `/nix/store`, заедно с хешът разира се
  - `src` за **път** в който се намира изходния архив
    - Искаме да автоматизираме изтеглянето на данни и запазването им, затова имаме fetchers

## Fetchers

- Функции, които по подадени аргументи изтеглят някакви файлове от интернет, слагат ги в `/nix/store` и връщат **път** към тези файлове
- Свеждат се до това да подадеш някакви данни, определящи url-ът, заедно с хеш
- Винаги се използва SHA256 хеш
- **Важна тънкост:** хешът е с предимство, т.е. ако промениш данните за url-ът, но не и хешът, пак ще се използват файловете от стария url.
  Хешът трябва да е празен или fakeSha за да накараме Nix да преизтегли данните от новата локация.
- Универсалният начин е да накраме Nix да изтегли данните и след това да видим каква грешка хвърля при разминаване с фалшивия хеш

---

< ДЕМО на различните fetch-ъри, как се ползват, аргументи >

### fetchurl

```
pkgs.fetchurl {
    url = "https://example.com/file.txt";
    hash = "sha256-lTeyxzJNQeMdu1IVdovNMtgn77jRIhSybLdMbTkf2Ww=";
}
```

fetchzip е същото, обаче автоматично и разархивира изтегления файл

### fetchFromGitHub

```
pkgs.fetchFromGitHub {
    owner = "username";
    repo = "repository";
    rev = "v1.0";
    hash = "";
}
```

---


### fetchgit

```
pkgs.fetchgit {
    url = "...";
    rev = "refs/tags/v1.0.0";
    hash = "";
    # Optional
    fetchSubmodules = false;
    leaveDotGit = false;
    deepClone = false;
    sparseCheckout = [ "dir/to/include" "other/dir" ];
}
```

- Fetcher-и като fetchFromGitHub използват fetchzip ако никоя от fetchgit-специфичните опции не е избрана
- **Внимание:** .git папката не е reproducible!

## Първите деривации с mkDerivation

< ДЕМО до края на презентацията, как пакетираме прости програми; трябва да измислим примери >
< В слайдовете трябва да вмъкнем кодът и малко инфо за програмите които пакетираме >
