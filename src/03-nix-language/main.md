# Nix езикът

## Преговор

Миналата седмица разгледахме `nix-` команди и направихме няколко съвсем елементарни деривации на Nix езикът.
Днес ще разгледаме подробно този език.

## Защо ни трябва нов език?

- JSON/YAML/...
  - Плюсове: пишат се лесно, форматът е прост, не е нужно да си програмист
  - Минуси: липсва програмиране, създаването на среда може да е сложно - условно избиране на компоненти, обхождане на компоненти и настройки, променяне на файлове/променливи/...

- C++/Java/Python/...
  - Плюсове: често срещани езици за програмиране, много налични ресурси/обучения
  - Минуси: операции извън програмата (обработка на файлове, шел променливи, ...) са сложни и/или много бавни, лесно може да напишем код който не дава възпроизводими резултати

- Haskell/Racket/Scheme/...
  - Плюсове: добре познати чисто-функционални езици, невъзпороизводим код е трудно и експлицитно
  - Минуси: големи езици, което означава че имат големи интерпретатори и са трудни за пренасяне към различни архитектури

## От какво се нуждаем

- "Обектни" типове данни, които ни позволяват да пишем нещо наподобяващо JSON
- Възможност за писане на изпълним код, за да поддържаме сложна логика
- Функционален, за да сме сигурно във възпроизводимостта си
- Малък, за да има малък, бърз и портативен интерпретатор

## Езикът Nix

- Чисто-функционален
- Lazy-evaluated
- Динамично-типизиран

<Припомняне/обяснение на `nix repl`, сладовете за езика ги правим в него>

## Примитивни типове данни

### String (UTF-8)

`"Hello World!"`

```
''
Здравей
  свят
!
''
```

### String interpolation

`"Count: ${1 + 2 + 3}"`

### null

`null`

---

### Number (integer/float)

`42`, `3.14`, `3.1e19`

### Boolean

`true`, `false`

### Path

`/usr/share/local`, `./test/file.txt`

### Path interpolation

`./files${2 * 3}/main.txt`


## Композитни типове: list

- Хетерогенен
- Константна дължина
- Lazy-evaluated
- Работим с него като с фунцкционален списък: използваме функции за да достъпим негови елементи

### Синтаксис

```
[ 1 "two" false ]
```

## Композитни типове: attrset

- Най-важния и уникален тип

### Синтаксис

```
{
  string = "hello";
  float = 3.141;
  null = null;
  list = [ 1 "two" false ];
  attribute-set = {
    a = "hello";
    b = 2;
    c = false;
  };
}
```

---

- Достъпваме стойности с `.` синтаксис

### Синтаксис

```
{ a = 5; b = 6; }.a
{ a = 8; b = { x = 2; y = 3; }; }.b.x
```

```
var = { a = { x = 61; y = 82; }; b = 100; }
var.a.y
```

---

- Атрибтутите са произволни низове
- Когато се съставят от латински букви, цифри, тирета и долни черти, можем да изпуснем кавичките
- И когато правим интерполация можем да ги изпуснем
- Иначе ги добавяме

### Синтаксис

```
var1 = { "Ябълка" = 5; "Apricot & Peach!" = 7.21; }
var2 = "Ябълка"
var."Apricot & Peach!"
var.${var2}
```

## Композитни типове: безименна функция

- Функциите са first-class citizen
- Само един аргумент, на практика правим currying ако искаме повече аргументи
- Изпълнява израз който директно връща стойност (езикът е функционален after all)

### Синтаксис

```
input_argument_name: expression
```

### Пример с "няколко" аргумента

```
x: y: (x + 1) * y
```

---

- Извикване става чрез изреждане на аргументите след функцията
- За да разграничим кои шпации са част от "тялото" на функцията и кои извън, ограждаме с кръгли скоби

### Пример променлива

```
var = x: y: (x + 1) * y
var 5 7
```

### Пример директно

```
(x: y: (x + 1) * y) 5 7
```

---

- Когато е аргумент на list трябва да го оградим в скоби заради спейсовете

### Синтаксис

```
[ 1 (x: y: (x + 1) * y) "Hi" ]
```

---

- Друг метод да имаме няколко аргумента е да използваме attrset като аргумент
- Много често срещан pattern, затова имаме "деструктуриране"

### Деструктуриране на attrset

```
x: x.a + x.b
{ a, b }: a + b
{ a, b }@x: x.a + b
x@{ a, b }: x.a + b
```

---

- Ако подадения attrset има повече аргументи ще получим грешка
- Можем да го избегнем (т.е. да игнорираме) чрез три точки

### Деструктуриране на някои атрибути

```
var = { a, b, ... }: a + b
var { a = 5; b = 6; c = 7; }
```

---

- Можем и да зададем стойности по подразбиране, ако не присъстват в attrset

### Стойности по подразбиране

```
var = { a ? 12, b ? 30 }: a + b
var {}
```

## Конструкции

- Всичко това бяха стойности
- Имаме и конструкции, които връщат стойности но не са стойност сами по себе си

### rec

Рекурсивни attrset, т.е. всеки атрибут е наличен на атрибтутите след него.

```
rec { a = 5; b = a + 1; c = a * b; }
```

### let

Истинският начин да създаваме променливи, без ексклузивното за `nix repl`, е чрез `let` израз.
Просто дефинираме променливи за изразът на дадена стойност, нямаме "глобални" променливи (функционално програмиране).

```
let x = 6; y = 1; in x + y * y
```

---

### if-else

Условен израз.
Отново, функционално програмиране, всичко връща стойност, нямаме само `if` без `else`, защото ако условието е грешно няма да имаме стойност за връщане.

```
if e1 then e2 else e3
```

### with

Работи като `let`, обаче му подаваш attrset вместо отделни `name = value` клаузи.

```
with { a = 81; b = 36; }; a + b 
```

е еквивалентно на

```
let a = 81; b = 36; in a + b
```

---

### inherit

Създава `name = name` клаузи по подадена променлива.
Полезно в дефинирането на attrset и let изрази.

```
var = 10
let x = { inherit var; }; in x.var
```

### or

В attrset достъпване може да използваме `or` след него за стойност по подразбиране

```
{ a = 7; }.b or 9
```

### Коментари

`#` за едноредови (от знака до края на реда)

`/* ... */` за многоредови

## Оператори

- Аритметически: `+`, `-`, `*`, `/`, unary `-`
- Логически: `<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`
  - Импликация: `->`
  - attrset има атрибут: `?`
- Конкатенация: `+`, работи при низове и пътища (смесено също!)
- Конкатенация на списъци: `++`
- Обновяване на attrset: `//` (връща левия attrset като елементите на десния се добавят или заменят на левия)

## Вградени неща

- `builtins` и всичко в него

< Тук имаме увод във функционално програмиране; тая част я давам на Павел >
