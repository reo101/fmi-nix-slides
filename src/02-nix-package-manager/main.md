---
title: Nix пакетният мениджър (команди)
date:
---

## Миналата лекция

::: nonincremental

- Разпространение на програми и съответните проблеми
- Nix как разрешава тези проблеми
- Инсталирахме и ползвахме Nix

:::

# Команди, съставящи Nix

## Здрач на версия 2

- Официалното издание на Nix е версия 2

- От последните няколко години се разработва версия 3, базирана на flake-ове (материал от средата на курса)

- Почти цялата общност употребява версия 3

- За сега ще работим главно с версия 2 и в конкретни случаи ще се възползваме от подобренията на версия 3

---

- Във V2 за всяко действие има команда, започваща с "nix-": `nix-build`, `nix-shell`, ...

- Във V3 всичко е обединено в една команда, `nix`, и действията се определят от аргумента: `nix build`, `nix shell`, ...

- Аргументите напълно се различават между версиите

---

- `nix-env` е много лоша команда, променя глобалната среда когато не е нужно.

  **Няма** да я разглеждаме, **няма** да я ползваме.

- За жалост, V2 е официалното, така че в почти всички документации се говори за `nix-env` като "начинът да използаш Nix".

## Включване на V3 командите

Има два начина:

1. Временния, който е да се извиква `nix` с аргументи:

   ```bash
   nix --extra-experimental-features "nix-command flakes" ...
   ```

2. Постоянния, в `~/.config/nix/nix.conf` или `/etc/nix/nix.conf` се добавя:

   ```config
   experimental-features = nix-command flakes
   ```

# Бърз увод в Nix системата

- Nix командите са директно свързани с пакетите

- Пакети се пишат на специален програмен език

- Ще ги погледнем повърхностно и в следващите лекции ще задълбаем

## Кратък увод в Nix езикът

- Езикът с който пишем пакети се нарича **Nix**.

  Не, името не е объркващо...

- Той е функционален, лениво-оценен и динамично-типизиран.
  Поддържа:

  - Стандартни аритметични оператори: `+`, `-`, `*`, `/`, `%`
  - Стандартни булеви оператори: `&&`, `||`, `!`, `==`, `!=`, `<`, `<=`, `>`, `>=`
  - Едноредови коментари започват с `#`
  - Израз `if condition then first else second`,  
    `first` и `second` трябва да имат еднакъв тип

---

- За изпълнение на Nix код ще използваме `nix repl`

- Въвеждаме израз и се принтира неговия резултат

- **Само тук** можем да направим `varname = expression`, за да създадем променлива и след това да я използваме свободно

- За някои типове не се принтират всичките му данни, трябва да сложим `:p` в началото

## Важни типове данни

### Булеви

```nix
true false
```

### Числа (цели и дробни)

```nix
2874 -300 182.384 1.5e7
```

---

### Низове (едноредови и многоредови)

```nix
"Hello World!"
''
Низ
 на
  много
   редове
''
```

Поддържат интерполация, т.е. в низ можем да напишем `${expr}` и това ще се замени със стойността на Nix израза.

```nix
"Sum: ${2 + 5}!"
```

### Път във файловата система

```nix
./directory /usr/share/bin ../test.txt
```

---

### Списъци

Хетерогенен контейнер, т.е. списък с елементи от различен тип.

```nix
[ 3 ~/Desktop "Hello" { x = 10; } (a: a * a * a) ]
```

---

### Атрибутни множества (attribute set; attrset)

Аналогът на `struct` или `class` в други езици.

```nix
{
  a = 5;
  b = "Hello";
  c = ./.;
  d = {
    m = 19.2;
  };
  d.p = -1000;
}
```

Достъпваме атрибути с `.`

```nix
{ x = 182; y = 192; }.x    # Връща 182
```

---

### Безименни функции

Функциите са "first class citizen".
Функция приема само един аргумент, но можем да върнем функция.

Извикваме с аргумент като поставим аргумента след дефиницията.
Трябва да оградим функцията със скоби, за да разграничим кога дефиницията свършва.

```nix
(var: var + 5) 10     # Връща 15
(a: b: a * b - 3) 2 4 # Връща 5
(ats: ats.x * ats.y) { x=7; y=8; } # Връща 56
```

Когато подаваме атрибутни множества, имаме удобен синтаксис с който директно достъпваме атрибутите:

```nix
({ x, y }: if x < y then x else y) { x = 1.414; y = 3.14; }
# Горното е напълно същото като
(nums: if nums.x < nums.y then nums.x else nums.y) { x = 1.414; y = 3.14; }
```

## Кратък увод в Nix пакети

- Всеки "пакет" се дефинира чрез едно предопределено атрибутно множество, което се подава на вградената функция `derivation`.

- Тя използва атрибутите, за да създаде редицата инструкции наречени "деривация", които описват как да се изтеглят ресурсите, да се компилира, да се инсталира.

- Много е базова, има фунцкии над нея, които опростяват употребата ѝ.  
От тях ще разглеждаме само някои [trivial builders](https://ryantm.github.io/nixpkgs/builders/trivial-builders/).

---

Достъп към тези функции получаваме след като изпълним в `nix repl`:

```nix
:l <nixpkgs>
```

Това зарежда всички Nix пакети, заедно с една редица функции.

Удобен сайт за разглеждане на пакетите се намира в [search.nixos.org](https://search.nixos.org/packages).
Обаче в `nix repl` не може да извикваме програми директно.
Все пак ще ги използваме като зависимости на деривации.

---

- Всеки "trivial builder" е функция, връщаща деривация.
  Можем да я компилираме директно в `nix repl`:

  ```nix
  :b ...
  ```

- Една деривация **винаги трябва да има изход!**
  Винаги е достъпна shell променливата `$out`, която може да се третира като директория или файл.
  Винаги трябва да вмъкнем нещо в нея.

- Ще се налага да четем файлове, Nix има вградена функция за тази цел `builtins.readFile`, която приема път към файл.
  Съчетавайки я с `:p` можем да видим съдържанието все едно сме извикали `cat`.

  ```nix
  :p builtins.readFile ~/.bashrc
  ```

---

### runCommand

Изпълнява команда по време на компилиране.
Приема три аргумента:

- `name` - низ за име
- `env` - атрибутно множество за зависимости (`buildInputs`) и променливи в средата
- `buildCommand` - низ за shell командата, която ще се изпълни

```nix
runCommand "Test" { tev = 301; } "echo $tev > $out"
```

```nix
runCommand "hello" { buildInputs = [ neofetch ]; } "neofetch > $out"
```

---

### writeTextFile

Създава текстови файл под `/nix/store`.
Приема едно атрибутно множество със следните атрибути:

- `name` - низ за име; файлът ще се намира под `/nix/store/HASH-name`
- `text` - низ за съдържание на файлът
- `executable` - (по желание) булева стойност дали файлът е изпълним (полезно за скриптове)

```nix
writeTextFile { name = "awesome"; text = "Super awesome text!"; }
```

```nix
writeTextFile {
  name = "hello";
  text = ''
  #!/bin/sh
  echo Hello World > $out
  '';
  executable = true;
}
```

---

### writeShellApplication

Подобно на `writeTextFile`, обаче за създаване на shell скриптове.
Файлът се намира под `/nix/store/.../bin/name`, винаги е изпълним, автоматично се създава shebang и се минава през стриктна проверка за скриптове.

Плюсът е, че вместо `executable` приема `runtimeInputs`, в което можем да поставим списък от пакети.

```nix
writeShellApplication {
  name = "hello";
  runtimeInputs = [ neofetch ];
  text = ''
    echo Hello World > "''${out-}"
    neofetch >> "''${out-}"
  '';
}
```

# Nix V2 команди

## nix-build

- `nix repl` е удобно за тестване, но не е практично за сериозна работа

- Искаме да изкараме нашия пакет в самостоятелен файл.
  
  Пишем същото, обаче на първия ред добавяме:

  ```nix
  with import <nixpkgs> { };
  ```

  Това върши *същото* като `:l <nixpkgs>` в `nix repl`.

- Сега можем да извикаме `nix-build ./package.nix` и ще получим пътя към компилирания пакет.

## nix-shell

- `nix-shell` приема Nix израз според който да създаде локална среда

- Понякога се нуждаем от среда в която имаме всички зависимости и променливи на един пакет, без самия пакет да е компилиран.

  Извикваме с всички `.nix` файлове, съдържащи деривация за компилиране:

  ```bash
  nix-shell ./package1.nix ./package2.nix ...
  ```

- Понякога се нуждаем от локална среда в която са достъпни редица пакети

  Извикваме с `-p` аргументът:

  ```bash
  nix-shell -p PACKAGE1 PACKAGE2 ...
  ```

---

Толкова често се ползва второто, че е създадена специална функция над `derivation`:

### mkShell

Приема едно атрибутно множество със следните атрибути:

- `packages` - списък с пакети
- `shellHook` - (по желание) низ за shell скрипт, който да се изпълни преди зареждането на средата
- `name` - (по желание) низ за име

```nix
with import <nixpkgs> { };
mkShell {
  packages = [ hello neofetch ];
  shellHook = ''
    echo Hello World
  '';
}
```

---

- Ако файлът в който въведем `mkShell` деривацията се казва `shell.nix`, тогава може да извикаме `nix-shell` без аргументи!

- Можем и да я извикваме директно с израз:

  ```nix
  nix-shell --expr 'runCommand "Test" { tev = 301; } "echo $tev > $out"'
  ```

---

Можем и да го използваме за създаване на среда в скриптове:

```python
#!/usr/bin/env nix-shell
#!nix-shell -i python3 -p python3 python3Packages.numpy python3Packages.scipy

import numpy as np
from scipy.sparse.csgraph import connected_components
from scipy.sparse import csr_matrix

arr = np.array([
  [0, 1, 2],
  [1, 0, 0],
  [2, 0, 0]
])

print(connected_components(csr_matrix(arr)))
```

## nix-store

`nix-store` е примитивната команда, която менижира всичко в `nix-store`.

На практика рядко трябва да я използваме, но е релевантно да знаем какво прави.

< обяснение на по-значими флагове и ДЕМО >

## nix-collect-garbage

Удобство над `nix-store --gc`.
Позволява да изтрием неща, които не ни трябват.

Когато се направи `nix-shell -p PACKAGE`, `PACKAGE` се добавя в `/nix/store`, обаче след като излезем от шел-а няма да се изтрие.
Би било твърде неудобно ако искаме същият шел след 5 минути и да трябва да инсталираме отново.

Затова Nix премахва неща само когато му кажеш, никога сам (освен определена настройка)!

---

Сама по себе си, тази команда трие точно тези програми: инсталирани, обаче не са зависимост на нещо, което сме казали, че трябва да стои.

< граф на /nix/store >
