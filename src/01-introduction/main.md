# Идеи, концепции и история на Nix

## Проблеми при дистрибуцията на софтуер

- Трябва да инсталираш програма
- Трябва да инсталираш зависимостите на програмата
- Програми/библиотеки се инсталират на редица **глобални** локации: `/lib`, `/bin`, `C:\Program Files`, `/Applications`, ...
- Конфигурации се инсталират на редица **глобални** (спрямо потребителя) локации: `/etc`, `~/.config`, `%APPDATA%`, ...

---

Мотика!

- Трудно инсталираме повече от една версия на програма
- Трудно е да инсталираме две програим с различни версии на зависимости
- Инсталирането на нови програми зависи от глобалното състояние, т.е. спрямо това какво сме инсталирали и конфигурирали, резултатът по време на инсталация/употреба може да е различен
- При премахването на програма, трябва да знаем къде точно се е вмъкнала и да внимаваме да не премахнем зависимост, която се използва от друг
- Трябва да теглим само програми които се поддържат от архитектурата на машината, ОС, ...

---

Последните две се оправят чрез така наречените "пакетни мениджъри".

Даваш им редица адреси в които да търсят програми.
Казваш им какво искаш да инсталираш.

Те автоматично избират бинарки за коректната архитектура/ОС/..., и следят къде и какво се инсталира.
Така при деинсталиране знаят какво да махнат и какво да оставят (кои споделени зависимости).

Първите 3 въпроса остават нерешени.

## Какво можем да направим?

### Инсталиране на повече от една версия на програма/зависимост

Всяка програма се съхрнява в уникална директория, спрямо името и версията си

Правим съпоставяне между това което програмата иска и това което може да получи.
Примерно, програмата иска `/bin/gcc`, даваме и `/somewhere/gcc-13.0.0`.

---

### Инсталиране зависи от глобалното състояние

Създаваме локални състояния, които имат само това което трябва и правят нужните съпоставяния.

Нуждаем се от много високо ниво на възпроизводимост!
Това локално не може да позволи **нищо** да звиси от глобалното, иначе цялата схема се обезсмисля.

---

Пакетните мениджъри решават последните два проблема.

Тези схеми решават първите три.

Не можем ли да съставим пакетен мениджър, който реализира тези схеми и да решим всички проблеми?

Можем!

## Nix пакетният мениджър

Всички тези проблеми и конкретните решения са описани от Eelco Dolstra.
Той кръстил пакетният си мениджър **Nix**.

Първоначалните идеи/реализации са започнали през 2002-2003.

Теорията кулминира в докторската му дисертация на темата през 2006.
Но той продължава да разработва.

Версия 1.0 на пакетния мениджър е излязла през 2012.

Версия 2.0 през 2018.

## Конкретни решения на последните 3 проблема

Една бинарка идва с много неща които ни пречат: статични/динамични библиотеки, пътища във файловата система, ...

Нека ние да си компилираме програмите (по-късно ще разберем защо това е ок).

Лесно можем да закърпим сорс-кодът, така че всяко срещане на `/bin/gcc` да се замени с `/somewhere/gcc-13.0.0` (чрез програми като sed, awk, perl, ...).

---

Това оправя самата програма директно, но не оправя съответния и компилатор.
Той все още може да извиква неща от `/bin` и все още да извършва статични/динамични връзки чрез неща в `/lib`.

Следователно, трябва да сме създали компилаторът по същия начин както програмата: компилиране на сорс-кодът и неговата промяна.
А какво става с компилаторът на компилаторът?

Намираме се в истинска chicken and the egg дилема!

---

Трябва ни още нещо: patchElf.

Ако една бинарка включва статично-свързани зависимости, става изключително трудно да ги премахнем и заменим (това е част от причината защо искаме да компилираме програми).
Обаче, динамично-свързаните зависимости се определят главно от един път, а пътищата са низове!

patchElf е програма, която позволява лесно да заменим динамичните връзки!

---

Тоест, компилираме в обикновенна система нашия компилатор само и единствено чрез динамични връзки.
Изтегляме всичко от което се нуждае в нашите пътища (`/somewhere`) и пускаме patchElf по него.

Сега можем да компилираме нашата програма, чиито сорс-код сме изменили да използва неща само от `/somewhere`, и всички нейни статични и динамични връзки ще са спрямо `/somewhere`.

**Оправихме всички проблеми, свързани с пътища в глобалната среда!**

---

За жалост глобалната среда включва още един голям компонент: мрежата.

Ние хубаво теглим сорс-код, но трябва да сме сигурни, че получаваме това което очакваме.
Тоест, да не се случи вчера като сме компилирали да е едно, и днеска друго, въпреки че линкът е един и същ.

Така фазата в която променяме пътищата в изходния код може да спре да работи.

Допълнително, за някои програми е нужно да се изтеглят допълнителни неща от интернет: docker images, ..., които не са програми.

---

На практика, няма как да задължим сайтовете да правят това което ние искаме, затова ще направим следващото най-добро: ще проверяваме.

Първият път когато изтегляме нещо от интернет и настройваме нашите процеси за него, ще вземем криптографския хеш на дадените данни.
Всеки следващ път като теглим ще проверим дали хешът на изтегленото съвпада с този на очакваното.

Така ще знаем бързо и лесно дали това което получаваме е същото като това за което сме си настроили процесите.
Разбира се, тази схема се обезсмисля ако програмата може да тегли нещо без ние да знаем, затова по време на компилация ще спрем интернетът на компилаторът.

---

Разрешили сме всички проблеми, обаче сме създали един нов: компилираме всички програми!
Компилацията е бавен и натоварващ процес, ако трябва да компилираме всеки компонент в една система, може да чакаме няколко дена!

Решението е още възпроизводимост.
Има още неща които са от глобалната среда, обаче не влиаят на компилационния процес: датата, денят, времевата зона, потребителското име, ...

Ако оправим и тях в компилациониня процес, получаваме една голяма сила - **винаги знаем, че спрямо едни и същи входни данни, ще компилираме до един и същ резултат!**

---

Следователно, можем да кешираме този резултат спрямо входовете!

Тоест, поглеждаме входовете които сме дефинирали за една програма и създаваме един голям хеш за тях.
Ако в кешът имаме резултат, съответстващ на хешът, можем да да пропуснем компилация и директно да изтеглим резултатът (защото знаем, че ще е същият).

Ако пък кешът се намира в интернет и всички машини ползващи Nix могат да се възползват от него, то **на практика почти никога няма да компилираме програмата!**

## Конкретики при Nix

Нашите неща се запазват в `/nix/store/`.

Всяка програма се идентифицира с хешът, името и версията.

Много от магиите се случват с промени по локални променливи като `PATH`.

## Нека да го пробваме!

```
sh <(curl -L https://nixos.org/nix/install) --daemon
```
